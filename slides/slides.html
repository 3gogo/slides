<div class="slide-layout-title">
	<h1>Nginx</h1>
	<h2>前端运维工程师的必备修养</h2>
</div>
<hr>
<div class="slide-layout-title">
	<h1>Why?</h1>
	<h2>为什么要懂 nginx</h2>
</div>
<hr>
<div>
	<h1>爆</h1>
	<h2>炸增长的互联网用户带来了巨大的挑战</h2>
	<p>截至2019年6月，我国网民规模达8.54亿</p>
	<p>较2018年底增长2598万</p>
	<p>---- 中国网信办</p>
</div>
<hr>
<div>
	<h1>横</h1>
	<h2>空出世的 nginx 服务器</h2>
	</br>
	<p>Nginx是轻量级 Web 服务器中的典型，由俄罗斯人 Igor Sysoev 开发。</p>
	<p>作为一个十分轻量级的 Web 服务器，Nginx 在俄罗斯访问量很高的 Rambler.ru 网站站点得到使用。</p>
	<p>在性能方面的优化做得很好，由于 Nginx 支持的是 Poll 内核模型，所以能处理高并发请求，相关报告指出，Nginx 可以处理五万左右的并发请求数。对于其它 Web服务器，当遭到恶意攻击或者用户访问量到达服务器峰值时，服务器的内存和 cpu 被过度消耗，会导致服务器无法响应请求甚至宕机。Nginx 采用的分阶段资源分配技术使得服务器对物理资源的消耗相对低得多，Nginx 官方网站表示服务器只需要几兆的内存就能够维持一万个无活动连接。</p>
	<p>所以 Nginx 可以有效防御某些服务器攻击。</p>
</div>
<hr>
<div>
	<h1>迅</h1>
	<h2>速抢占市场的 nginx</h2>
	</br>
	<p>由于其具有高可靠性、低内存消耗以及高并发连接等特点，更因为其开源的特性及灵活的可扩展性，在实际应用中特别是大型 Web
		应用系统上得到了广泛部署。</p>
	<p>根据 Netcraft 今年 10 月份最新公布的数据显示：全球活跃网站主流 Web 服务器采用 Nginx 部署量已经上升到了第一位（市场占有率达36%）。</p>
	</br>
	<p><img src="/assets/netcraft.png"></p>	
</div>
<hr>
<div>
	<h1>nginx</h1>
	<h2>为何高性能？</h2>
</div>
<hr>
<div>
	<h1>单</h1>
	<h2>线程的非阻塞 I/O 技术</h2>
	</br>
	<p>减少工作进程在磁盘 I/O 上的阻塞延迟。</p>
</div>
<hr>
<div>
	<h1>多</h1>
	<h2>路复用以及事件通知（epoll-根据fd上的callback来实现）</h2>
	</br>
	<p>当新的任务到达，Nginx 会将这个任务交给服务器中单独的进程。</p>
	<p>就是使用这个单线程工作进程来高效地处理连接，也正是由于这个工作进程，Nginx 才能应付成千上万的用户请求数。</p>
</div>
<hr>
<div>
	<h1>模块化</h1>
	</br>
	<p>各种操作系统的事件机制成就了 Nginx 的模块化模型，Nginx 于是成为了一款专门
		用于提高服务器性能的工具。</p>
	<p>下图展示Nginx 常用模块及其之间的关系：</p>
	</br>
	<p><img src="/assets/modules-relationship.png"></p>
</div>
<hr>
<div>
	<h1>master-slave 模型</h1>
	</br>
	<p>可以根据 SMP的特点，来有效减缓 worker 进程在磁盘 I/O 方面的阻塞延迟。</p>
</div>
<hr>
<div>
	<h1>热部署</h1>
	</br>
	<p>热部署是指在不重新搭建服务器的情况下就可以对系统进行升级维护，几乎不会影响用户使用。</p>
	<p>因此系统启动之后，甚至可以连续运行数月。</p>
</div>
<hr>
<div>
	<h1>类BSD许可证</h1>
	</br>
	<p>利于开发人员的改写扩展。</p>
</div>
<hr>
<div class="slide-layout-title">
	<h1>Nginx 语法</h1>
</div>
<hr>
<div>
	<h1>基本配置</h1>
	</br>
	<p><a href="https://codepen.io/3gogo/pen/JjKVYON?editors=0010">基础配置详解</a></p>
</div>
<hr>
<div>
	<h1>块配置项</h1>
	</br>
	<p>
		<code>
			events {
			...
			}
		</code>
	</p>
	<p>
		<code>
			http {
			...
			}
		</code>
	</p>
	<p>
		<code>
			upstream backend {
				...
			}
		</code>
	</p>
	<p>
		<code>
			server {
			...
			}
		</code>
	</p>
	<p>
		<code>
			events {
			...
			}
		</code>
	</p>
	<p>
		<code>
			location / {
				...
			}
		</code>
	</p>
	<br>
	<p>块配置项可以嵌套。内层块直接继承外层块，例如，基本配置的例子中，server块里的任意配置都是基于http块里的已有配置的。</p>
	<p>当内外层块中的配置发生冲突时，如何判断一个指令可以合并还是不可以合并呢？</p>
	<br>
	<p>指令分类：</p>
	<ol>
		<li>值指令--对这个指令下存储当时配置的值；</li>
		<li>动作类指令;</li>
	</ol>
	<p>值指令：不同块下可以合并，如root，access_log,gzip;</p>
	<p>动作类指令：指定行为，不可以合并，如rewrite，proxy_pass...</p>
	<br>
	<p>如果是值指令则遵从向上覆盖的继承规则。</p>
	<p>动作指令一般是不可以合并的，当然我们也可以通过源码可以判断出来这个指令是什么类型的指令。</p>
	<p><a href="https://blog.csdn.net/Edidaughter/article/details/109631677">参考博客</a></p>
</div>
<hr>
<div>
	<h1>Nginx 的配置</h1>
	<h2>location</h2>
	</br>
	<p>语法：location [=|~|~*|^~|@] /uri/ {...}</p>
	<p>配置块：server</p>
	<p>@表示仅用于Nginx服务内部请求之间的重定向，带有@的location不直接处理用户请求。</p>
	<p>
		<a href="https://cloud.tencent.com/developer/article/1631087">location会尝试根据用户请求中的URI来匹配上面的</a>
	</p>
	<p>以上各种匹配方式中，都只能表达为“如果匹配...则...”。如果需要表达“如果不匹配...则...”就很难直接做到。有一种解决方法是在最后一个location中使用/作为参数，它会匹配所有的HTTP请求，这样就可以表示如果不能匹配到前面的所有location，则由“/”这个location处理。</p>
</div>
<hr>
<div>
	<h1>文件路径的定义</h1>
	<h2>root</h2>
	</br>
	<p>语法：root path</p>
	<p>默认：root html</p>
	<p>配置块：http、server、location、if</p>
	<p>例如，定义资源文件相对于HTTP请求的根目录。</p>
	<p>
		<em>
		location /download/ {
			root /opt/web/html;
		}
		</em>
	</p>
	<p>在上面的配置中，如果有一个请求的URI是<em>/download/index/test.html</em>，那么Web服务器将会返回服务器上<em>/opt/web/html/download/index/test.html</em>文件的内容。</p>
</div>
<hr>
<div>
	<h1>文件路径的定义</h1>
	<h2>alias</h2>
	</br>
	<p>语法：root path</p>
	<p>配置块：location</p>
	<p>alias也是用来设置文件资源路径的，它与root的不同点主要在于如何解读紧跟location后面的uri参数，这将会致使alias与root以不同的方式将用户请求映射到真正的磁盘文件上。例如，如果有一个请求的URI是/conf/nginx.conf，而用户实际想访问的文件在/usr/local/nginx/conf/nginx.conf，</p>
	<p>那么想要使用alias来进行设置的话，可以采用如下方法:</p>
	<p>
		<em>
		location /conf {  
			alias /usr/local/nginx/conf/;      
		}
		</em>
	</p>
	<p>如果用root设置，那么语句如下所示：</p>
	<p>
		<em>
		location /conf {  
			root /usr/local/nginx/;          
	    }
		</em>
	</p>
	<p>使用alias时，在URI向实际文件路径的映射过程中，已经把location后配置的/conf这部分字符串丢弃掉，因此，/conf/nginx.conf请求将根据alias path映射为path/nginx.conf。root则不然，它会根据完整的URI请求来映射，因此，/conf/nginx.conf请求会根据root path映射为path/conf/nginx.conf。这也是root可以放置到http、server、location或if块中，而alias只能放置到location块中的原因。</p>
	<p> alias后面还可以添加正则表达式，例如：</p>
	<p>
		<em>
		location ~ ^/test/(\w+)\.(\w+)$ {  
			alias /usr/local/nginx/$2/$1.$2;  
		}
		</em>
	</p>
	<p>这样，请求在访问/test/nginx.conf时，Nginx会返回/usr/local/nginx/conf/nginx.conf文件中的内容。</p>
</div>
<hr>
<div>
	<h1>Yes</h1>
	<p>So, I made a simple presentation framework for the web.  You're looking at it.</p>
</div>
<hr>
<div>
	<h1>Simple</h1>
	<p>You just make slides in plain old HTML, and the framework will present them for you.  You can create themes and layouts with CSS.</p>
</div>
<hr>
<div>
	<h1>Examples</h1>
	<p>The next few slides show some examples of very simple layouts you might expect to see in a slide presentation.</p>
</div>
<hr>
<div class="slide-layout-title">
	<h1>Just a Title</h1>
</div>
<hr>
<div class="slide-layout-title">
	<h1>Title</h1>
	<h2>With Subtitle</h2>
</div>
<hr>
<div>
	<h1>Title</h1>
	<h2>Subtitle</h2>
	<p>This is a slide with title, subtitle, and some paragraph text. This slide uses a different layout that shifts everything upward to account for the paragraph text.</p>
</div>
<hr>
<div>
	<h1>Title</h1>
	<h2>Subtitle and Bullets</h2>
	<ul>
		<li>Titles, and paragraph text are just HTML elements</li>
		<ul>
			<li>e.g. <code>h1</code>, <code>h2</code>, <code>p</code></li>
		</ul>
		<li>Bullets, of course</li>
		<ul>
			<li>nest,</li>
			<ul>
				<li>as you'd expect</li>
			</ul>
		</ul>
	</ul>
</div>
<hr>
<div>
	<h1>Links</h1>
	<p>Since it's HTML, linking is easy, and means you don't have to jump out of Powerpoint or Keynote to view the link.  The back button works, too ... <a href="http://google.com/">try it</a></p>
</div>
<hr>
<div>
	<h1>More Links</h1>
	<p>You can link to other slides, too, and the back button will still work like you think it should.  <a href="#11">Try it</a>.</p>
</div>
<hr>
<div>
	<h1>Layouts</h1>
	<h2>Just use CSS</h2>
	<ul>
		<li>Layouts are just CSS classes</li>
		<ul>
			<li>e.g. <code>slide-layout-title</code></li>
		</ul>
		<li>There are a few built-in, as you've seen</li>
		<li>You can define your own</li>
	</ul>
</div>
<hr>
<div>
	<h1>Themes</h1>
	<h2>You guessed it, CSS</h2>
	<ul>
		<li>Themes are also CSS classes</li>
		<li>You're looking at the 'gray' theme right now</li>
		<li>You can, of course, define your own</li>
	</ul>
</div>
<hr>
<div>
	<h1>Transitions</h1>
	<h2>CSS again!</h2>
	<ul>
		<li>Slide transitions are defined using CSS3</li>
		<li>This presentation uses the 'fade' transition</li>
		<li>Can be integrated into a theme or mixed-and-matched</li>
		<li>And yep, you can define your own</li>
	</ul>
</div>
<hr>
<div>
	<h1>Mobile</h1>
	<h2>Landscape, portrait, touch, swipe</h2>
	<p>It has mobile viewport support in the builtin template and themes, plus touch and swipe event support for navigation.</p>
</div>
<hr>
<div>
	<h1>Engineered</h1>
	<h2>MVC, OOCSS, and AMD</h2>
	<p>Cutting edge tech, packaged for simplicity.  Use it out of the box, or drop in code for your own slide models, views, and controllers.</p>
</div>
<hr>
<div class="slide-layout-title">
	<h1>Get it</h1>
	<h2>Now available on <a href="https://github.com/briancavalier/slides">github</a></h2>
</div>
